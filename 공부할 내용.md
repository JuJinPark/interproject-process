### 공부할 내용
- oauth 인증 및 절차
- mysql naming convention
- 동시성 프로그램밍 화면에 어드민이 여러 명이서 작업할떄
- git flow
- factory method구현후

- exception 처리 및 너무 많은 메서드에서 처리해야하는 문제 
- api key 와 같은 부분은 설정파일에서 받아온느 식으로 변경예정
- 각 api 인스턴스(google,hiworks,github) 이부분을 enum으로 설정후 enum에서 .get instance로 할지 고민중
- 스프링 security
- rest api /redis
- 도메인 주도 설계
- 객체지향
- 스프링 부트 및 스프링 이해 후 설명 가능하게 기본 동작 이해 및 숙지
- rest api return code and value 추가 및 변경은 해당 객체 delete no content 
- best practice heatos에 이동할 url 또는 이후 다른 작업을 위한 상태반환
- jpa oslc 사용시 controller 바로 repository 호출해서 간단한 건 처리 가능 
- @autowired 주입시 필드보다는 생성자 또는 setter 가 좋다
- 세터로 하면 circular dependcy라고 서로 참조가 일어나면 에러가 발생할수잇으니 세터는 lazy로딩이다.
(https://www.baeldung.com/circular-dependencies-in-spring)(https://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/)
- jpa deltebyxx 는 단건이 아닌 여러건을 삭제하더라도 먼저 조회를 하고 그 결과로 얻은 엔티티 데이터를 1건씩 삭제한다는 것입니다.(https://jojoldu.tistory.com/235) \
  그래서 대규모 삭제시 성능이 않좋을수 있다.
- onetomany manytoone fetch가 eager 일대 query문 다른듯 manytoone은 조인 이고 oneto many는 다시 select 인듯  


### 고민하는 내용
- 로그인 절차
    - jwt를 탈취해 다른 사람이 통신에 사용하는 경우(토근자체만 문제가 없으면 유효성 검사에 걸리지 않음) sesion 를 사용? 그러면 jwt사용하는 의미가 퇴색될거 같다.
    - 쿠기를 사용한다면 만료시간과 jwt 만료 시간
    - jwt토큰과 기존 다른 로그인후에 확인하는 절차 
    - vue와 서버가 통신할떄는 당연히 jwt를 기반으로 한다 그러나 뷰자체 라우터로 페이징을 할떄는 권한및 인증 검사를 
      vue-router에는 beforeEnter라는 인터셉터가 있는데 라우팅 직전에 실행되는 함수다. 
      beforeEnter 인터셉터는 from, to, next 세 개 인자를 받는 함수다. 이를 이용해 서버로 페이지 이동마다 인증을 받은후 인증정보가 없을 경우 로그인 화면으로 리다이렉트 하도록 했다.
    - vue와의 통신 방향 라우터러 할시에 서버에서 검증하는 방식 특정 url로 검정을 계속해서 받을 거냐 아님 그냥 요청해서 받을거냐

- 로그인 절차 로직상 
  일단 사내 이메일로 무조건 최초는 로그인(하이웍스)로 한다.
  hiworks와연동하여 accesstoken 과 refreshtoken을 받아온다. 이를 spring redis 에 사번과 함께 저장한다.
  이후 자체 jwt를 발급한다. 여기에 사번또는 세션 아이디를 넣는다.
  프론트는 jwt를 vuex 저장한다 이후 서버와 통신떄마다 jwt를 헤더에 넣어서 보낸다.(아님 모든 작업을 할떄마다 서버에서 jwt 체크후 리다이렉트또는 작업을 할수있게 해야하나,마커이동작업중 토큰 만료만 다 날라가나?)


  서버는 jwt 토큰 유형성 검사 한다(이부분 애매하다. 만약 탈취후 다른 사람이 이jwt를 기반으로 요청을 한다면? 이에 대응하기 위해 세션id를 넣어준다 그럼 jwt 의미가 퇴색 되지않느가 똔느 sessionid가 탈취될수도 있다)

  다른 소셜 로그인일 경우
  hiworks 로그인후 다른 소셜로그인 연동하기 
  이후 해당 소셜로그인 로그인하기 인증되면 이메일 테이블에 소셜 로그인 이메일 추가(redis에 이 accesstoken과 refresh token을 넣어두어야 할까?)

  이후 해당 소셜로그인 으로 로그인하면
  소셜로그인인중후 이메일 테이블레 등록 되어있는지 체크 되었이다면 이후 절차는 하이웍스와 동일

  구글과 같은 다른 api의 기능은 로그인만 한다는 가정이면 굳이 필요한가? 아니라면 하이웍스로그인자도 구글 로그인을 통해 받아와야함 

-RestTemplate을 사용할 때 주의할 점
RestTemplate 은 기본적으로 conneciton pool을 사용하지 않기 때문에 매 요청마다 handshake를 수행한다. 이를 방지하기 위해 다음과 같은 설정을 추가한 Custom RestTemplate을 빈으로 등록하여 사용할 수 있다.(https://a1010100z.tistory.com/entry/SpringBoot-RestTemplate-vs-Webclient작성중)
-jpa는 no args constructor가 꼭필요하다.이유는 hibernate creates instance of entities using reflection it uses Class.newInstance() methode which require a no argumetn constructor to create an instance.

- crud jap repository 는 기본적으로 transactional을 구현하고 잇으나 그래도 service 에서 도 해주는 게 좋은가?
- set null caseade 와 같은 constraint 는 디비에서 직접 해주어야하고 jpa 에서하느것은 entity manager에 있는 오브젝트에 한에서 적용된다.
- mock bean vs mock
  - mock bean-기존에 사용되던 스프링 Bean이 아닌 Mock Bean을 주입합니다. 어노테이션 내부에 문자열 값을 등록한 것은 기존에 선언된 Bean 객체를 덮어쓰기 위함입니다.
  - mock- Mock 객체를 생성한다.
 - @InjectMock-class의 instance를 생성하고 @Mock(도는 @Spy) annotation으로 생성된 mock instance를 class의 instance에 주입한다. 
 - @spybean-@MockBean은 given에서 선언한 코드 외에는 전부 사용할 수 없습니다. 
반면에 @SpyBean은 given에서 선언한 코드 외에는 전부 실제 객체의 것을 사용합니다. 
이미 존재하는 Bean을 SpyBean으로 Wrapping한 형태라고 생각하시면 됩니다. 
- JPA Respository entity manager있어서 이미 container차원에서 관리해준다.
- db 정책은 no action
- 한 서비스단위로 transaction 주는게 맞다.
- vo vs dto vs entity  차이(https://gmlwjd9405.github.io/2018/12/25/difference-dao-dto-entity.html)




- git source tree 사용하는데 원격에는 feature branch 사라졌는데도 있다. 왜그러나?
- feature 로 작업을 두곳에서 하다가 하나에서 머지 시키고 없었으면 집에서는 그 브랜티 그냥 지우면 돼나?
- 서로의 관계를 변경해주여할떄가 언제냐? 예 자리정보에 변화가 잇으면 자리변경오쳥에 잇는 모든 해당 자리정보를 다 바꿔주어야 하나?
- import static 문제
- fetchtype 결정하기 (모든 연관관계는 지연로딩으로 개발하고 상황을보고 필요한곳 즉 같이 자주 검색되는곳만 즉시로딩으로 변경) manytoone onetoone 등 하나는 즉시 one to many many to many 는 지연로딩이다.
  또 하나 이상 컬런섹에 즉시 로딩 하지말기 너무 많은 결과물이 선택 될수 잇음 그리고 내부 조인 외부조인 을 선택할수있따 외래키에 nullble 속성을 주면 내부 하지만 one to many  와 many to many는 무조건 외부
- cascade 와 같은 정책은 아직;
- 테스트 코드 잘작성하기 분할하는 법등
- spring security 로 로그인 구현 하는 방향
- spring scheduler 또는 spring batch로 직원 및 부서 정보 받아서 주기적 업데이트 및 인서트하는 방향


- object mapper 변경 및 테스트
- map struct 구동 원리
- object mapper 인터페이스화
- api만들기 계속
- 어떤 api를만들지 모든게 다 서비스가 필요한가?




 
---
### 구현방향

- 직원테이블 동기화
  하이웍스 로그인후 직원테이블에 그 사번이 없으면 새로운 입사한 사람으로 인지후 인서트
  퇴사자는 어드민이 직접제거 방법
  완전동기화를 하게되면 직원테이블에서 자리컬럼만 자리테이블에 사번으로 넣어주면 될까?
- jwt 토큰 검증
- jwt cookie sessionid 로 통신하기
- feature/모듈명 이런식으로 작업 commit 시 깃 issue 닫기
- feature 도 푸시해서 원격으로 작업해라
- 자리중복이 발생하도 자리번호는 직원 테이블에 있으니 사번만 중복이 안일어나면 테이블상에서는 문제없음 -> 관리자페이지에서 중복된 자리는 화면에 계속 보여주게해 처리를 강제한다.
- spring boot lecttuce 사용법
- redis session id 생성과정 및 같은 브라우저만 session 공유진 어덯게 중복확인 한느지

#1. 자체토근 인증법
- 자체 토근 발급후 필터로 모든 요청 마다 token을 있는지 확인 및 없으면 로그인 페이지
- 있으면 제대로 된 토큰 인지와 redis에서 확인?

2. 로그인 accesstoken 받아오기

# 하이웍스(사내이메일) 
- AuthorizationUrl
  param에도 access_type이 있어야함(refresh token을 원할시 offline)
- access token 요청
  post 요청
  body로 (auth_code,client_id,client_secret,grant_type,accesstype)
  accesstoken 만료기간은 리턴값이 없음 한시간이 default 
- resource 요청
  헤더에 (Authorization:Bearer {},Content-type:application/json)

# google
- AuthorizationUrl
  param에도 access_type이 있어야함(refresh token을 원할시 offline)
- access token 요청
  post 요청
  param으로 (code,client_id,client_secret,redirect_url,grant_type)
- resource 요청
  헤더에 (Authorization:Bearer {})  
# github
- AuthorizationUrl
  평범
- access token 요청
  post 요청
  param으로 (client_id,client_secret,code)
  x refresh token 무한 호출가능 아마
- resource 요청
  헤더에 (Authorization:Bearer {})  


3. 자리변경후 자리테이블 처리방법
 - 자리 변경 승인이나면 기존 자리의 emp null로 해주고 새로운 자리에 update 로 덮어씌우기
 - 그러면 그전에 앉아 있던 사람은 자연스럽게 자리를 잃는다 그래서 자리가 배정안된 사람들을 상시로 옆에 보여주면서 체크할수있도록 구현 

4. 엔티티 설계
JPA oslv 표현 계층까지 영속서이 살아있다 하지만 controller 에서는 읽기만 가능 수정반영 안됨 하지만 수정후에 다른 서비스를 호출하면 그전게 반영됨
oslv 장점은 지연로딩을 사용해서 표현계층에서도 사용가능 하다는 점이다.






lazy 로딩후 조인어덯게 쿼리로 하는지 검사
jpa test 양방향 리스트에서 add 안해줫쓸떄
cascade 공부
h2 inmemeory 설치후 테스트
mpastruct 인터페이스 좀더 공부
clas diagram 수정
cacade option으로 null 만들기 공부

seat 과 floor시 floor 삭제시 seat 모두 삭제 cascde option
seat 삭제시 floor seat list에서 삭제 
여기서 preremove 를 했떠니 exception 발생

2가지 방안
seat 에서 floorid를 null로 주룻있게 하고 floor preremove 에서 null로 해버리고 cacasde option remove 또는 orphan remove=true로 한다.(장점 구현이 편하다하지만 not null 유지불가)

no proper mapper found error 500에 메세지를 리턴해야 하나?

delete 는 바로 flush 가 안된다. 
자리에서 floor 변경시 floor리스트에서 변경 되는지 확인

delete 문과 update 문 추측내용
jpql를 만들면 그전에 자동flush 된다
delete와 update는 entity manager를 통해 변경 됨으로 update 와 delete문은 쓰기 지연 저장소에 있따가 
그다음에 query 가 실행됨가동시에 예)jpql flush 된다 그다음 동작이 없을시에는 transaction 이 롤백 됨에 따라 flush 안됨
그럼 select 와 insert문은 왜 바로 flush 지 확인해보자


best way to update entity with many variables
update 시에 처리 방법
front에서 update 할시에 update 안할것도 똑같이 보내줭야하나?
그래서 다 update를 치나 아님 변한것만 service에서 확인해서 update를 치나
- 현재 생성하는 request dto를 사용 모든 값에 대해 update를 친다 하지만 이떄 객체도 어떻게 같다고 처리하는지

- request dto 사용 update 할것만 값을 넣어서 보낸다. service에서 null 이 아닌것만 체크한뒤 update 한다.
단점: reqeust dto creat와 같이 사용해서 null 값을 못보낼수도 있오  request dto update 와 create 분리
- update 한 내용과 함께 기존 유지된 값도 다시 다보낸다. service layer 변한 값을 일일이 기존 값과 체크한다. 그후 변경된 값만 update를 친다.

단점 갯수가 많을시에는 체크로직인 길어짐
- update 한 내용을 기존 유지도니 값도 다시 다보내다. 체크하지 않고 그냥 update 친다. entity manager 알아서 변경된 값만 update 문에서 수정하도록 equal hashcode를 작성해준다.

객체는 아디로 체크하고 select 로직이 안타게 
그냥 값은 무조건 update?
# 문제

- update 요청시 update를 안하는 기존값도 요청에 있어야 한다.


- update 요청시 update 하는 값만 요청 받는다. 향후 null 값이 아닌것만 update를 한다.

- setter 없이 객체 만들기 테스트용 온리 placetype
- isfloor changed  위치와 update문 전체적인 로직 처리 
- 서비스 테스트 케이스 만들기
- floor delete place도 다 지워지는 확인 테스트 케이스

    public PlaceResponseDetailsDTO createPlaceForTest(long floorId){


    }
